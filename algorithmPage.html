<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Algorithms</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="algoStyle.css">
</head>
<body data-spy="scroll" data-target="navbarSupportedContent ">

<header>
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <a class="navbar-brand" href="#"><i class="fas fa-atom fa-1x"></i>AlgoView</a>
        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
                aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        <div class="collapse navbar-collapse" id="navbarSupportedContent">
            <ul class="navbar-nav mx-auto">

                <li class="nav-item">
                    <a class="nav-link" href="index.html">About</a>
                </li>

                <li class="nav-item dropdown">
                    <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button"
                       data-bs-toggle="dropdown">Products
                    </a>
                    <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                        <a class="dropdown-item" href="dataStructuresPage.html">Data Structures</a>
                        <div class="dropdown-divider"></div>
                        <a class="dropdown-item" href="algorithmPage.html">Algorithms</a>
                        <div class="dropdown-divider"></div>
                        <a class="dropdown-item" href="">Interview Prep</a>
                    </div>
                </li>

                <li class="nav-item">
                    <a class="nav-link" href="contactPage.html">Contact</a>
                </li>

            </ul>
           <a href="signInPage.html"> <button class="btn text-dark" type="submit">Sign In</button></a>
        </div>
    </nav>

    <div class="mid">
        <video autoplay muted loop>
            <source class="embed-responsive" src="algorithmsFiles/algoVideo13.mp4" type="video/mp4">
        </video>
        <div class="hero text-center">
            <h2 class="text-light display-4 font-weight-bold">Welcome to Algorithms</h2>
            <p class="text-light mx-auto">This is where your journey begins</p>
            <a class="text-dark" href="#">Crash Course</a>
        </div>
    </div>
</header>

<!--The small sections begin here-->

<!--Binary Search-->
<section id="binarySearch" class="lightBackground py-5">
    <div class="row align-items-center">ss
        <div class="col px-5">
            <div class="row align-items-center">
                <div class="text col-sm-11 ">
                    <h1>Binary Search</h1>
                    <h3>Search a sorted array by repeatedly dividing the search interval in half. Begin with an interval
                        covering the whole array. If the value of the search key is less than the item in the middle of
                        the interval, narrow the interval to the lower half. Otherwise, narrow it to the upper half.
                        Repeatedly check until the value is found or the interval is empty.</h3>
                </div>
            </div>
            <div class="row">
                <div class="text col-sm-5">
                    <h2>Advantage</h2>
                    <h4>The idea of binary search is to use the information that the array is sorted and reduce the time
                        complexity to O(Log n) from a linear search where for each iteration is O(n). </h4>
                </div>
                <div class="text col-sm-5">
                    <h2>Complexity</h2>
                    <h4>The time complexity of Binary Search can be written as
                        T(n) = T(n/2) + c</h4>
                </div>
            </div>
        </div>
        <div class="col px-5">
            <iframe width="600" height="400"
                    src="https://www.youtube.com/embed/P3YID7liBug">
            </iframe>
        </div>
    </div>
</section>

<!--Merge Sort-->
<section id="mergeSort" class="darkBackground py-5">
    <div class="row align-items-center">

        <div class="col px-5">
            <iframe width="600" height="400"
                    src="https://www.youtube.com/embed/KF2j-9iSf4Q">
            </iframe>
        </div>

        <div class="col px-5">
            <div class="row align-items-center">
                <div class="text col-sm-11 ">
                    <h1>Merge Sort</h1>
                    <h3>Merge Sort is a Divide and Conquer algorithm. It divides the input array into two halves, calls
                        itself for the two halves, and then merges the two sorted halves. The merge() function is used
                        for merging two halves. The merge(arr, l, m, r) is a key process that assumes that arr[l..m] and
                        arr[m+1..r] are sorted and merges the two sorted sub-arrays into one</h3>
                </div>
            </div>
            <div class="row">
                <div class="text col-sm-5">
                    <h2>Idea</h2>
                    <h4>Auxiliary Space: O(n)
                        Algorithmic Paradigm: Divide and Conquer
                        Sorting In Place: No in a typical implementation
                        Stable: Yes, unless the list is very small in size</h4>
                </div>
                <div class="text col-sm-5">
                    <h2>Complexity</h2>
                    <h4>Sorting arrays on different machines. Merge Sort is a recursive algorithm and time complexity
                        can be expressed as following recurrence relation.
                        T(n) = 2T(n/2) + Î¸(n)</h4>
                </div>
            </div>
        </div>

    </div>
</section>

<!--Quick Sort-->
<section id="minimumDepthBT" class="lightBackground py-5">
    <div class="row align-items-center">ss
        <div class="col px-5">
            <div class="row align-items-center">
                <div class="text col-sm-11 ">
                    <h1>Find Minimum Depth of a Binary Tree</h1>
                    <h3>Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the
                        shortest path from the root node down to the nearest leaf node.</h3>
                </div>
            </div>
            <div class="row">
                <div class="text col-sm-5">
                    <h2>Idea</h2>
                    <h4>The idea is to traverse the given Binary Tree. For every node, check if it is a leaf node. If
                        yes, then return 1. If not leaf node then if the left subtree is NULL, then recur for the right
                        subtree. And if the right subtree is NULL, then recur for the left subtree. If both left and
                        right subtrees are not NULL, then take the minimum of two heights.</h4>
                </div>
                <div class="text col-sm-5">
                    <h2>Complexity</h2>
                    <h4>Searching: For searching element 2, we have to traverse all elements (assuming we do breadth
                        first traversal). Therefore, searching in binary tree has worst case complexity of O(n).
                        Insertion: For inserting element as left child of 2, we have to traverse all elements.
                        Therefore, insertion in binary tree has worst case complexity of O(n).
                        Deletion: For deletion of element 2, we have to traverse all elements to find 2 (assuming we do
                        breadth first traversal). Therefore, deletion in binary tree has worst case complexity of
                        O(n).</h4>
                </div>
            </div>
        </div>
        <div class="col px-5">
            <iframe width="600" height="400"
                    src="https://www.youtube.com/embed/vpMe2aZM6Kg">
            </iframe>
        </div>
    </div>
</section>

<!--QuickSort-->
<section id="depthFirstSearch" class="darkBackground py-5">
    <div class="row align-items-center">

        <div class="col px-5">
            <iframe width="600" height="400"
                    src="https://www.youtube.com/embed/Y40bRyPQQr0">
            </iframe>
        </div>

        <div class="col px-5">
            <div class="row align-items-center">
                <div class="text col-sm-11 ">
                    <h1>Depth-first Search</h1>
                    <h3>Depth-first search is an algorithm for traversing or searching tree or graph data structures.
                        The algorithm starts at the root node (selecting some arbitrary node as the root node in the
                        case of a graph) and explores as far as possible along each branch before backtracking. So the
                        basic idea is to start from the root or any arbitrary node and mark the node and move to the
                        adjacent unmarked node and continue this loop until there is no unmarked adjacent node. Then
                        backtrack and check for other unmarked nodes and traverse them. Finally, print the nodes in the
                        path.</h3>
                </div>
            </div>
            <div class="row">
                <div class="text col-sm-5">
                    <h2>Idea</h2>
                    <h4>Create a recursive function that takes the index of the node and a visited array.
                        Mark the current node as visited and print the node.
                        Traverse all the adjacent and unmarked nodes and call the recursive function with the index of
                        the adjacent node. </h4>
                </div>
                <div class="text col-sm-5">
                    <h2>Complexity</h2>
                    <h4>Time complexity: O(V + E), where V is the number of vertices and E is the number of edges in the
                        graph.
                        Space Complexity: O(V).
                        Since an extra visited array is needed of size V.</h4>
                </div>
            </div>
        </div>

    </div>
</section>

<!--Breadth-First Search-->
<section id="depthFirst" class="lightBackground py-5">
    <div class="row align-items-center">ss
        <div class="col px-5">
            <div class="row align-items-center">
                <div class="text col-sm-11 ">
                    <h1>Breadth-First Search</h1>
                    <h3>Breadth-First Traversal (or Search) for a graph is similar to Breadth-First Traversal of a tree.
                        The only catch here is, unlike trees, graphs may contain cycles, so
                        we may come to the same node again. To avoid processing a node more than once, we use a boolean
                        visited array. For simplicity, it is assumed that all vertices are reachable from the starting
                        vertex. </h3>
                </div>
            </div>
            <div class="row">
                <div class="text col-sm-5">
                    <h2>Idea</h2>
                    <h4>Space Complexity</h4>
                </div>
                <div class="text col-sm-5">
                    <h2>Complexity</h2>
                    <h4>O(V+E) where V is a number of vertices in the graph and E is a number of edges in the
                        graph.</h4>
                </div>
            </div>
        </div>
        <div class="col px-5">
            <iframe width="600" height="400"
                    src="https://www.youtube.com/embed/0u78hx-66Xk">
            </iframe>
        </div>
    </div>
</section>

<!-- Footer -->
<footer class="page-footer font-small special-color-dark pt-4">

    <!-- Footer Elements -->
    <div class="container">

        <!-- Social buttons -->
        <ul class="list-unstyled list-inline text-center">
            <li class="list-inline-item">
                <a class="btn-floating btn-fb mx-2">
                    <i class="fab fa-facebook fa-3x"> </i>
                </a>
            </li>
            <li class="list-inline-item">
                <a class="btn-floating btn-tw mx-2">
                    <i class="fab fa-twitter fa-3x"> </i>
                </a>
            </li>
            <li class="list-inline-item">
                <a class="btn-floating btn-gplus mx-2">
                    <i class="fab fa-google-plus-g fa-3x"> </i>
                </a>
            </li>
            <li class="list-inline-item">
                <a class="btn-floating btn-li mx-2">
                    <i class="fab fa-linkedin-in fa-3x"> </i>
                </a>
            </li>
        </ul>
        <!-- Social buttons -->

    </div>
    <!-- Footer Elements -->

    <!-- Copyright -->
    <div class="footer-copyright text-center py-3">Â© 2020 Copyright:
        University of Stirling
    </div>
    <!-- Copyright -->

</footer>
<!-- Footer -->

<script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.9.2/dist/umd/popper.min.js"
        integrity="sha384-IQsoLXl5PILFhosVNubq5LC7Qb9DXgDA9i+tQ8Zj3iwWAwPtgFTxbJ8NT4GN1R8p"
        crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.min.js"
        integrity="sha384-cVKIPhGWiC2Al4u+LWgxfKTRIcfu0JTxR+EQDz/bgldoEyl4H0zUF0QKbrJ0EcQF"
        crossorigin="anonymous"></script>
<script src="https://kit.fontawesome.com/333cabe4a1.js" crossorigin="anonymous"></script>


</body>
</html>